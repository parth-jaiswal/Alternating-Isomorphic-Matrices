IMPORT itertools

IMPORT numpy as np

IMPORT more_itertools as mit

IMPORT numpy as np

IMPORT time





DEFINE FUNCTION datasum(p):

    if row sum NOT EQUALS 1 for any row
        return False
    if column sum NOT EQUALS 1 for any column
        return False
    
    return TRUE
    

DEFINE FUNCTION partialsum(p):

    p=np.array(p)                                           #p is now array of arrays
    FOR i IN p:                                             # condition FOR asm
        SET sum TO 0
        FOR j IN i:                                         #j is a single element of array 'i'
            sum += j
            IF sum not in [0,1]:
                RETURN False
    RETURN True





DEFINE FUNCTION negativecheck(p):               # 1st and last rows and columns should not have -1

    SET first_r TO p[0]                                                     #selects whole first row

    SET first_c TO p[:, 0]                                                  #selcts whole first col

    SET last_c TO p[:, len(p) - 1]                                              

    SET last_r TO p[len(p) - 1]

    IF -1 IN first_r or -1 IN first_c or -1 IN last_r or -1 IN last_c:

        RETURN False

    RETURN True





DEFINE FUNCTION comp_array(a, m):                                       # checking FOR transpose

    FOR j IN m:

        IF (a EQUALS j).all():

            RETURN False

    RETURN True





CALL def blocks(a):   # Finding positions of -1s and linking them to their blocks

    SET positive TO 0

    SET negative TO 0

    SET order TO len(a)

    FOR i IN a:

        positive += i.count(1)

        negative += i.count(-1)

    INITIALISE empty set n              # set of 1s connected with a -1

    INITIALISE arr as empty dictionary 

    SET z TO 0                          #key of arr

    FOR i IN range(1, order - 1):

        FOR j IN range(1, order - 1):

            SET flag TO -1

            SET k TO set()     #set of '1's corresponding to a -1

            IF a[i][j] EQUALS -1:

                SET p TO j

                FOR m IN range(i - 1, -1, -1):

                    IF a[m][p] EQUALS 1:

                        k.add((m, p))

                        break

                FOR m IN range(i + 1, order):

                    IF a[m][p] EQUALS 1:

                        k.add((m, p))

                        break

                FOR m IN range(p - 1, -1, -1):

                    IF a[i][m] EQUALS 1:

                        k.add((i, m))

                        break

                FOR m IN range(p + 1, order):

                    IF a[i][m] EQUALS 1:

                        k.add((i, m))

                        break

                FOR r IN arr.keys():

                    FOR q IN k:

                        IF q IN arr[r]['p']:            #if a common '1' is found

                            SET flag TO r

                IF flag != -1:                       # IF block has the same linked 1s, then joining them as connected blocks

                    SET arr[flag] TO {'p': arr[flag]['p'].union(k), 'n': arr[flag]['n'] + [(i, j)]}

                ELSE:  # new block IF 1s found are unique

                    SET arr[z] TO {'p': k, 'n': [(i, j)]}

                    z += 1

                SET n TO n.union(k)

    OUTPUT("No of blocks: ", z + positive - len(n))

    OUTPUT("No of free 1's: ", positive - len(n))

    RETURN arr, positive - len(n)





CALL check(p, a, comb, n):   # For checking IF all permutations of a given matrix or block have row and column sum=1

    SET r TO 1

    SET t TO 2

    FOR i IN p:

        SET f TO 0

        SET matrix TO [a[j] FOR j IN i]

        SET data TO np.matrix(matrix)

        IF n EQUALS 2:

            SET data TO np.transpose(data)

        SET tp TO np.transpose(data)

        IF negativecheck(data):

            IF partialsum(data) and partialsum(tp):

                FOR j IN comb:

                    IF (data EQUALS j):

                        SET f TO 1

                IF f EQUALS 0:

                    r += 1

                    comb.append(data)



        SET tp_a TO np.transpose(comb[0])          #comb 0 is the initial matrix (block)

        FOR i IN comb:

            if(i==tp_a).all():

                SET t TO 1

    RETURN r, t, comb





CALL def matform(order, pos, rmin, cmin):   # Forming individual blocks

    SET matrix TO [[0 FOR i IN range(0, order)] FOR i IN range(0, order)]

    FOR j IN pos['p']:

        SET matrix[j[0] - rmin][j[1] - cmin] TO 1

    FOR j IN pos['n']:

        SET matrix[j[0] - rmin][j[1] - cmin] TO -1

    SET ecol TO []

    SET erow TO []

    FOR i IN range(0, order):

        SET f TO 0

        FOR j IN matrix[i]:

            IF j != 0:

                SET f TO 1

                break

        IF f EQUALS 0:

            erow.append(i)

    SET matrix TO np.transpose(

        np.matrix(matrix)).tolist()  # Finding and removing blank rows and columns WHILE maintaing order

    FOR i IN range(0, order):

        SET f TO 0

        FOR j IN matrix[i]:

            IF j EQUALS 1 or j EQUALS -1:

                SET f TO 1

                break

        IF f EQUALS 0:

            ecol.append(i)

    SET matrix TO np.transpose(np.matrix(matrix)).tolist()

    WHILE (len(erow) EQUALS len(ecol) and len(erow) != 0):

        matrix.pop(erow[-1])

        SET matrix TO np.transpose(np.matrix(matrix)).tolist()

        matrix.pop(ecol[-1])

        SET matrix TO np.transpose(np.matrix(matrix)).tolist()

        erow.pop()

        ecol.pop()

    RETURN matrix





CALL def isomorph(k):   # Forming order of individual blocks and sending it to matform along with positions of 1s and -1s

    SET matcomb TO []

    FOR i IN k.keys():

        SET rmin TO 1000

        SET cmin TO 1000

        SET rmax TO -1

        SET cmax TO -1

        FOR j IN k[i]['p']:

            SET rmin TO min(rmin, j[0])

            SET rmax TO max(rmax, j[0])

            SET cmin TO min(cmin, j[1])

            SET cmax TO max(cmax, j[1])

        SET order TO max(rmax - rmin, cmax - cmin) + 1

        matcomb.append(matform(order, k[i], rmin, cmin))

    RETURN matcomb





CALL def asmcomb(a):   # Generating all possible row and column permutations  

    SET order TO len(a)

    SET p TO list(itertools.permutations([i FOR i IN range(0, order)], order))

    # OUTPUT ("P: ")

    # OUTPUT(p)

    # OUTPUT()

    SET comb TO [np.matrix(a)]

    SET r, t, comb TO check(p, a, comb, 1)

    SET a TO np.transpose(np.matrix(a)).tolist()

    SET c, t, comb TO check(p, a, comb, 2)

    OUTPUT("COMB")

    OUTPUT(comb)

    RETURN r, c, t, comb





CALL def binomial(n, c):  

    RETURN fact(n) // (fact(c) * fact(n - c))  # binomial calculation





CALL def fact(a):  

    IF a EQUALS 0 or a EQUALS 1:

        RETURN 1

    RETURN a * fact(a - 1)  # factorial





IF __name__ EQUALS "__main__":

    

    #OUTPUT("Enter order of matrix")

    a=[]

    order= int(INPUT())

    FOR i IN range(0,order):

        OUTPUT(f"Enter Row {i+1} with a single space between each element")

        q=INPUT().split()

        FOR j IN range(0,len(q)):

            q[j]=int(q[j])

        a.append(q)

    OUTPUT()

    

    IF datasum(np.matrix(a)):

        SET (k, free) TO blocks(a)

        SET iso TO 0

        SET matcomb TO isomorph(k)                  # contains all blocks IN matrix form

        SET combarr TO []

        FOR i IN range(0, len(matcomb)):

            SET r, c, t, comb TO asmcomb(matcomb[i])

            combarr.append([r, c, t, comb, len(matcomb[i]), False])

        SET isogroup TO []

        FOR i IN range(0, len(matcomb)):

            IF not combarr[i][5]:

                FOR j IN range(i + 1, len(matcomb)):

                    IF combarr[i][4] EQUALS combarr[j][4] and (

                            combarr[i][0] * combarr[i][1] EQUALS combarr[j][0] * combarr[j][1]) and \

                            combarr[i][2] EQUALS combarr[j][2]:

                        FOR k IN combarr[i][3]:

                            IF (k EQUALS matcomb[j]).all():

                                IF combarr[i][5] EQUALS False:

                                    SET combarr[i][5] TO True

                                    iso += 1

                                SET combarr[j][5] TO True

                                iso += 1

                                SET f TO 1

                                break

                isogroup.append(iso)



        OUTPUT("ISOMORPHIC BLOCKS: ", iso)

        SET rct TO 1

        FOR i IN range(0, len(combarr)):

            rct *= combarr[i][0] * combarr[i][1] * combarr[i][2]

            OUTPUT(

                f"Block {i + 1}: Order={combarr[i][4]} Row={combarr[i][0]} Column={combarr[i][1]} Transpose={combarr[i][2]} Isomorphic={combarr[i][5]}")

        SET answer TO 1

        FOR i IN range(0, free):

            answer *= order ** 2

            order -= 1

        SET answer TO answer // fact(free)

        FOR i IN range(0, len(combarr)):

            answer *= binomial(order, combarr[i][4]) ** 2

            SET order TO order - combarr[i][4]

        FOR i IN isogroup:

            answer //= fact(i)

        answer *= rct

        OUTPUT("ANSWER:", answer)



    ELSE:

        OUTPUT("Matrix not ASM") 





